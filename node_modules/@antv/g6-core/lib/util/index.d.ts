import * as MathUtil from './math';
import { ext, mat3 } from '@antv/matrix-util';
declare const Util: {
    transform: typeof ext.transform;
    mat3: typeof mat3;
    defaultSubjectColors: string[];
    compare: (attributeName: string) => (m: any, n: any) => number;
    getLineIntersect: (p0: import("@antv/g-base").Point, p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point, p3: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getRectIntersectByPoint: (rect: import("..").IRect, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getCircleIntersectByPoint: (circle: import("..").ICircle, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getEllipseIntersectByPoint: (ellipse: import("..").IEllipse, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    applyMatrix: (point: import("@antv/g-base").Point, matrix: import("..").Matrix, tag?: 0 | 1) => import("@antv/g-base").Point;
    invertMatrix: (point: import("@antv/g-base").Point, matrix: import("..").Matrix, tag?: 0 | 1) => import("@antv/g-base").Point;
    getCircleCenterByPoints: (p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point, p3: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    distance: (p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point) => number;
    scaleMatrix: (matrix: import("..").Matrix[], ratio: number) => import("..").Matrix[];
    floydWarshall: (adjMatrix: import("..").Matrix[]) => import("..").Matrix[];
    getAdjMatrix: (data: import("..").GraphData, directed: boolean) => import("..").Matrix[];
    translate: (group: import("@antv/g-base").IGroup, vec: import("@antv/g-base").Point) => void;
    move: (group: import("@antv/g-base").IGroup, point: import("@antv/g-base").Point, animate?: boolean, animateCfg?: import("..").GraphAnimateConfig) => void;
    scale: (group: import("@antv/g-base").IGroup, ratio: number | number[]) => void;
    rotate: (group: import("@antv/g-base").IGroup, angle: number) => void;
    getDegree: (n: number, nodeIdxMap: import("..").NodeIdxMap, edges: import("..").EdgeConfig[]) => number[];
    isPointInPolygon: (points: number[][], x: number, y: number) => boolean;
    intersectBBox: (box1: Partial<import("..").IBBox>, box2: Partial<import("..").IBBox>) => boolean;
    isPolygonsIntersect: (points1: number[][], points2: number[][]) => boolean;
    Line: typeof MathUtil.Line;
    getBBoxBoundLine: (bbox: import("..").IBBox, direction: string) => any;
    itemIntersectByLine: (item: import("..").Item, line: MathUtil.Line) => [import("..").IPoint[], number];
    fractionToLine: (item: import("..").Item, line: MathUtil.Line) => number;
    getPointsCenter: (points: import("..").IPoint[]) => import("..").IPoint;
    squareDist: (a: import("..").IPoint, b: import("..").IPoint) => number;
    pointLineSquareDist: (point: import("..").IPoint, line: MathUtil.Line) => number;
    isPointsOverlap: (p1: any, p2: any, e?: number) => boolean;
    pointRectSquareDist: (point: import("@antv/g-base").Point, rect: import("..").IRect) => number;
    pointLineDistance: (line: any, point: any) => number;
    lerp: (start: number, end: number, alpha: number) => number;
    roundedHull(polyPoints: import("gl-matrix").vec2[], padding: number): string;
    paddedHull(polyPoints: import("gl-matrix").vec2[], padding: number): string | {
        x: number;
        y: number;
    }[];
    getSpline: (points: import("..").IPoint[]) => import("@antv/path-util/lib/types").PathCommand[];
    getControlPoint: (startPoint: import("..").IPoint, endPoint: import("..").IPoint, percent?: number, offset?: number) => import("..").IPoint;
    pointsToPolygon: (points: import("..").IPoint[] | (string | {
        x: number;
        y: number;
    })[], z?: boolean) => string;
    pathToPoints: (path: any[]) => any[];
    getClosedSpline: (points: import("..").IPoint[]) => any[];
    getBBox: (element: import("..").IShapeBase, group: import("@antv/g-base").IGroup) => import("..").IBBox;
    getLoopCfgs: (cfg: import("..").EdgeData) => import("..").EdgeData;
    getLabelPosition: (pathShape: any, percent: number, refX: number, refY: number, rotate: boolean) => Partial<{
        rotate: number;
        textAlign: "center" | "left" | "right" | "start" | "end";
        angle: number;
        x: number;
        y: number;
        text: string;
        stroke: string;
        opacity: number;
        fontSize: number;
        fontStyle: "normal" | "italic" | "oblique";
        fontFamily: string;
        fontWeight: number | "bold" | "normal" | "bolder" | "lighter";
        fill: string;
        rotateCenter: string;
        lineWidth: number;
        shadowColor: string;
        shadowBlur: number;
        shadowOffsetX?: number;
        shadowOffsetY?: number;
        position: string;
        textBaseline: "top" | "middle" | "bottom" | "hanging" | "alphabetic" | "ideographic";
        offset: number;
        fillOpacity: number;
        background?: {
            fill?: string;
            stroke?: string;
            lineWidth?: number;
            radius?: number | number[];
            padding?: number | number[];
        };
    }>;
    traverseTree: <T extends {
        children?: T[];
    }>(data: T, fn: (param: T) => boolean) => void;
    traverseTreeUp: <T_1 extends {
        children?: T_1[];
    }>(data: T_1, fn: (param: T_1) => boolean) => void;
    getLetterWidth: (letter: any, fontSize: any) => number;
    getTextSize: (text: string, fontSize: number) => number[];
    plainCombosToTrees: (array: import("..").ComboConfig[], nodes?: import("..").NodeConfig[]) => import("..").ComboTree[];
    reconstructTree: (trees: import("..").ComboTree[], subtreeId?: string, newParentId?: string) => import("..").ComboTree[];
    getComboBBox: (children: import("..").ComboTree[], graph: import("..").IAbstractGraph) => import("@antv/g-base").BBox;
    shouldRefreshEdge: (cfg: any) => any;
    cloneBesidesImg: (obj: any) => {};
    uniqueId: (type: string) => string;
    formatPadding: (padding: import("..").Padding) => number[];
    cloneEvent: (e: import("..").IG6GraphEvent) => import("..").IG6GraphEvent;
    isViewportChanged: (matrix: import("..").Matrix) => boolean;
    isNaN: (input: any) => boolean;
    calculationItemsBBox: (items: import("..").Item[]) => {
        x: number;
        y: number;
        width: number;
        height: number;
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    processParallelEdges: (edges: any, offsetDiff?: number, multiEdgeType?: string, singleEdgeType?: string, loopEdgeType?: string) => any;
};
export default Util;
